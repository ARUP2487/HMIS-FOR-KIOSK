Now let me use bulk_file_writer to create the backend server:
Action: {"tool_name": "mcp_bulk_file_writer", "tool_arguments": {"files": [{"path": "/app/backend/server.py", "content": "from fastapi import FastAPI, APIRouter, HTTPException, Depends, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom dotenv import load_dotenv\nfrom starlette.middleware.cors import CORSMiddleware\nfrom motor.motor_asyncio import AsyncIOMotorClient\nimport os\nimport logging\nfrom pathlib import Path\nfrom pydantic import BaseModel, Field, ConfigDict\nfrom typing import List, Optional\nimport uuid\nfrom datetime import datetime, timezone, timedelta\nimport bcrypt\nimport jwt\n\nROOT_DIR = Path(__file__).parent\nload_dotenv(ROOT_DIR / '.env')\n\n# MongoDB connection\nmongo_url = os.environ['MONGO_URL']\nclient = AsyncIOMotorClient(mongo_url)\ndb = client[os.environ['DB_NAME']]\n\n# JWT Configuration\nSECRET_KEY = os.environ.get('JWT_SECRET_KEY', 'your-secret-key-change-in-production')\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24 * 7  # 7 days\n\n# Security\nsecurity = HTTPBearer()\n\n# Create the main app\napp = FastAPI()\napi_router = APIRouter(prefix=\"/api\")\n\n# ==================== MODELS ====================\n\n# User Models\nclass UserCreate(BaseModel):\n    username: str\n    password: str\n    full_name: str\n    phone: str\n    email: str\n    role: str = \"patient\"  # patient or admin\n    language_preference: str = \"en\"  # en or bn\n\nclass UserLogin(BaseModel):\n    username: str\n    password: str\n\nclass User(BaseModel):\n    model_config = ConfigDict(extra=\"ignore\")\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    username: str\n    full_name: str\n    phone: str\n    email: str\n    role: str\n    language_preference: str\n    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))\n\nclass UserResponse(BaseModel):\n    user: User\n    token: str\n\n# Doctor Models\nclass DoctorCreate(BaseModel):\n    name: str\n    name_bengali: str\n    specialization: str\n    specialization_bengali: str\n    qualifications: str\n    experience_years: int\n    consultation_fee: float\n    available_days: List[str]  # [\"Monday\", \"Tuesday\", etc.]\n    consultation_hours: str  # \"9:00 AM - 5:00 PM\"\n    image_url: Optional[str] = None\n\nclass Doctor(BaseModel):\n    model_config = ConfigDict(extra=\"ignore\")\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    name: str\n    name_bengali: str\n    specialization: str\n    specialization_bengali: str\n    qualifications: str\n    experience_years: int\n    consultation_fee: float\n    available_days: List[str]\n    consultation_hours: str\n    image_url: Optional[str] = None\n    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))\n\n# Appointment Models\nclass AppointmentCreate(BaseModel):\n    doctor_id: str\n    appointment_date: str  # YYYY-MM-DD format\n    slot_time: str  # \"10:00 AM\"\n\nclass Appointment(BaseModel):\n    model_config = ConfigDict(extra=\"ignore\")\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    patient_id: str\n    patient_name: str\n    doctor_id: str\n    doctor_name: str\n    appointment_date: str\n    slot_time: str\n    slot_number: int\n    status: str  # pending, confirmed, completed, cancelled\n    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))\n\n# Billing Models\nclass BillingCreate(BaseModel):\n    appointment_id: str\n    amount: float\n    description: str\n\nclass Billing(BaseModel):\n    model_config = ConfigDict(extra=\"ignore\")\n    id: str = Field(default_factory=lambda: str(uuid.uuid4()))\n    patient_id: str\n    patient_name: str\n    appointment_id: str\n    amount: float\n    description: str\n    payment_status: str  # pending, paid\n    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))\n\n# ==================== HELPER FUNCTIONS ====================\n\ndef hash_password(password: str) -> str:\n    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')\n\ndef verify_password(password: str, hashed: str) -> bool:\n    return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))\n\ndef create_access_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\nasync def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    try:\n        token = credentials.credentials\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        user_id: str = payload.get(\"sub\")\n        if user_id is None:\n            raise HTTPException(status_code=401, detail=\"Invalid authentication credentials\")\n        \n        user = await db.users.find_one({\"id\": user_id}, {\"_id\": 0, \"password_hash\": 0})\n        if user is None:\n            raise HTTPException(status_code=401, detail=\"User not found\")\n        \n        # Convert ISO string timestamps back to datetime objects\n        if isinstance(user.get('created_at'), str):\n            user['created_at'] = datetime.fromisoformat(user['created_at'])\n        \n        return User(**user)\n    except jwt.ExpiredSignatureError:\n        raise HTTPException(status_code=401, detail=\"Token has expired\")\n    except jwt.JWTError:\n        raise HTTPException(status_code=401, detail=\"Could not validate credentials\")\n\nasync def get_admin_user(current_user: User = Depends(get_current_user)):\n    if current_user.role != \"admin\":\n        raise HTTPException(status_code=403, detail=\"Admin access required\")\n    return current_user\n\n# ==================== AUTH ROUTES ====================\n\n@api_router.post(\"/auth/register\", response_model=UserResponse)\nasync def register(user_data: UserCreate):\n    # Check if username exists\n    existing_user = await db.users.find_one({\"username\": user_data.username})\n    if existing_user:\n        raise HTTPException(status_code=400, detail=\"Username already exists\")\n    \n    # Hash password\n    password_hash = hash_password(user_data.password)\n    \n    # Create user\n    user_dict = user_data.model_dump(exclude={'password'})\n    user_obj = User(**user_dict)\n    \n    # Prepare document for MongoDB\n    doc = user_obj.model_dump()\n    doc['password_hash'] = password_hash\n    doc['created_at'] = doc['created_at'].isoformat()\n    \n    await db.users.insert_one(doc)\n    \n    # Create token\n    token = create_access_token({\"sub\": user_obj.id})\n    \n    return UserResponse(user=user_obj, token=token)\n\n@api_router.post(\"/auth/login\", response_model=UserResponse)\nasync def login(credentials: UserLogin):\n    # Find user\n    user_doc = await db.users.find_one({\"username\": credentials.username}, {\"_id\": 0})\n    if not user_doc:\n        raise HTTPException(status_code=401, detail=\"Invalid username or password\")\n    \n    # Verify password\n    if not verify_password(credentials.password, user_doc['password_hash']):\n        raise HTTPException(status_code=401, detail=\"Invalid username or password\")\n    \n    # Convert timestamp\n    if isinstance(user_doc.get('created_at'), str):\n        user_doc['created_at'] = datetime.fromisoformat(user_doc['created_at'])\n    \n    # Remove password hash\n    user_doc.pop('password_hash', None)\n    user_obj = User(**user_doc)\n    \n    # Create token\n    token = create_access_token({\"sub\": user_obj.id})\n    \n    return UserResponse(user=user_obj, token=token)\n\n@api_router.get(\"/auth/me\", response_model=User)\nasync def get_me(current_user: User = Depends(get_current_user)):\n    return current_user\n\n# ==================== DOCTOR ROUTES ====================\n\n@api_router.post(\"/doctors\", response_model=Doctor)\nasync def create_doctor(doctor_data: DoctorCreate, current_user: User = Depends(get_admin_user)):\n    doctor_obj = Doctor(**doctor_data.model_dump())\n    \n    doc = doctor_obj.model_dump()\n    doc['created_at'] = doc['created_at'].isoformat()\n    \n    await db.doctors.insert_one(doc)\n    return doctor_obj\n\n@api_router.get(\"/doctors\", response_model=List[Doctor])\nasync def get_doctors(search: Optional[str] = None, specialization: Optional[str] = None):\n    query = {}\n    \n    if search:\n        # Search in name (both English and Bengali) and specialization\n        query[\"$or\"] = [\n            {\"name\": {\"$regex\": search, \"$options\": \"i\"}},\n            {\"name_bengali\": {\"$regex\": search, \"$options\": \"i\"}},\n            {\"specialization\": {\"$regex\": search, \"$options\": \"i\"}},\n            {\"specialization_bengali\": {\"$regex\": search, \"$options\": \"i\"}}\n        ]\n    \n    if specialization:\n        if \"$or\" in query:\n            # Combine with existing search\n            query = {\n                \"$and\": [\n                    query,\n                    {\"$or\": [\n                        {\"specialization\": {\"$regex\": specialization, \"$options\": \"i\"}},\n                        {\"specialization_bengali\": {\"$regex\": specialization, \"$options\": \"i\"}}\n                    ]}\n                ]\n            }\n        else:\n            query[\"$or\"] = [\n                {\"specialization\": {\"$regex\": specialization, \"$options\": \"i\"}},\n                {\"specialization_bengali\": {\"$regex\": specialization, \"$options\": \"i\"}}\n            ]\n    \n    doctors = await db.doctors.find(query, {\"_id\": 0}).to_list(1000)\n    \n    for doctor in doctors:\n        if isinstance(doctor.get('created_at'), str):\n            doctor['created_at'] = datetime.fromisoformat(doctor['created_at'])\n    \n    return doctors\n\n@api_router.get(\"/doctors/{doctor_id}\", response_model=Doctor)\nasync def get_doctor(doctor_id: str):\n    doctor = await db.doctors.find_one({\"id\": doctor_id}, {\"_id\": 0})\n    if not doctor:\n        raise HTTPException(status_code=404, detail=\"Doctor not found\")\n    \n    if isinstance(doctor.get('created_at'), str):\n        doctor['created_at'] = datetime.fromisoformat(doctor['created_at'])\n    \n    return Doctor(**doctor)\n\n# ==================== APPOINTMENT ROUTES ====================\n\n@api_router.post(\"/appointments\", response_model=Appointment)\nasync def create_appointment(appointment_data: AppointmentCreate, current_user: User = Depends(get_current_user)):\n    # Get doctor details\n    doctor = await db.doctors.find_one({\"id\": appointment_data.doctor_id}, {\"_id\": 0})\n    if not doctor:\n        raise HTTPException(status_code=404, detail=\"Doctor not found\")\n    \n    # Get the next slot number for this doctor and date\n    existing_appointments = await db.appointments.find({\n        \"doctor_id\": appointment_data.doctor_id,\n        \"appointment_date\": appointment_data.appointment_date,\n        \"status\": {\"$ne\": \"cancelled\"}\n    }).to_list(1000)\n    \n    slot_number = len(existing_appointments) + 1\n    \n    # Create appointment\n    appointment_obj = Appointment(\n        patient_id=current_user.id,\n        patient_name=current_user.full_name,\n        doctor_id=appointment_data.doctor_id,\n        doctor_name=doctor['name'],\n        appointment_date=appointment_data.appointment_date,\n        slot_time=appointment_data.slot_time,\n        slot_number=slot_number,\n        status=\"confirmed\"\n    )\n    \n    doc = appointment_obj.model_dump()\n    doc['created_at'] = doc['created_at'].isoformat()\n    \n    await db.appointments.insert_one(doc)\n    \n    # Create billing record\n    billing_obj = Billing(\n        patient_id=current_user.id,\n        patient_name=current_user.full_name,\n        appointment_id=appointment_obj.id,\n        amount=doctor['consultation_fee'],\n        description=f\"Consultation with Dr. {doctor['name']}\",\n        payment_status=\"pending\"\n    )\n    \n    billing_doc = billing_obj.model_dump()\n    billing_doc['created_at'] = billing_doc['created_at'].isoformat()\n    await db.billing.insert_one(billing_doc)\n    \n    return appointment_obj\n\n@api_router.get(\"/appointments/my\", response_model=List[Appointment])\nasync def get_my_appointments(current_user: User = Depends(get_current_user)):\n    appointments = await db.appointments.find(\n        {\"patient_id\": current_user.id},\n        {\"_id\": 0}\n    ).sort(\"created_at\", -1).to_list(1000)\n    \n    for appointment in appointments:\n        if isinstance(appointment.get('created_at'), str):\n            appointment['created_at'] = datetime.fromisoformat(appointment['created_at'])\n    \n    return appointments\n\n@api_router.get(\"/appointments/{appointment_id}\", response_model=Appointment)\nasync def get_appointment(appointment_id: str, current_user: User = Depends(get_current_user)):\n    appointment = await db.appointments.find_one({\"id\": appointment_id}, {\"_id\": 0})\n    if not appointment:\n        raise HTTPException(status_code=404, detail=\"Appointment not found\")\n    \n    # Check if user owns this appointment or is admin\n    if appointment['patient_id'] != current_user.id and current_user.role != \"admin\":\n        raise HTTPException(status_code=403, detail=\"Access denied\")\n    \n    if isinstance(appointment.get('created_at'), str):\n        appointment['created_at'] = datetime.fromisoformat(appointment['created_at'])\n    \n    return Appointment(**appointment)\n\n# ==================== BILLING ROUTES ====================\n\n@api_router.get(\"/billing/my\", response_model=List[Billing])\nasync def get_my_billing(current_user: User = Depends(get_current_user)):\n    bills = await db.billing.find(\n        {\"patient_id\": current_user.id},\n        {\"_id\": 0}\n    ).sort(\"created_at\", -1).to_list(1000)\n    \n    for bill in bills:\n        if isinstance(bill.get('created_at'), str):\n            bill['created_at'] = datetime.fromisoformat(bill['created_at'])\n    \n    return bills\n\n@api_router.get(\"/billing/{bill_id}\", response_model=Billing)\nasync def get_billing(bill_id: str, current_user: User = Depends(get_current_user)):\n    bill = await db.billing.find_one({\"id\": bill_id}, {\"_id\": 0})\n    if not bill:\n        raise HTTPException(status_code=404, detail=\"Bill not found\")\n    \n    # Check if user owns this bill or is admin\n    if bill['patient_id'] != current_user.id and current_user.role != \"admin\":\n        raise HTTPException(status_code=403, detail=\"Access denied\")\n    \n    if isinstance(bill.get('created_at'), str):\n        bill['created_at'] = datetime.fromisoformat(bill['created_at'])\n    \n    return Billing(**bill)\n\n@api_router.put(\"/billing/{bill_id}/pay\")\nasync def pay_bill(bill_id: str, current_user: User = Depends(get_current_user)):\n    bill = await db.billing.find_one({\"id\": bill_id}, {\"_id\": 0})\n    if not bill:\n        raise HTTPException(status_code=404, detail=\"Bill not found\")\n    \n    # Check if user owns this bill\n    if bill['patient_id'] != current_user.id:\n        raise HTTPException(status_code=403, detail=\"Access denied\")\n    \n    # Update payment status\n    await db.billing.update_one(\n        {\"id\": bill_id},\n        {\"$set\": {\"payment_status\": \"paid\"}}\n    )\n    \n    return {\"message\": \"Payment successful\", \"bill_id\": bill_id}\n\n# ==================== ADMIN ROUTES ====================\n\n@api_router.get(\"/admin/appointments\", response_model=List[Appointment])\nasync def get_all_appointments(current_user: User = Depends(get_admin_user)):\n    appointments = await db.appointments.find({}, {\"_id\": 0}).sort(\"created_at\", -1).to_list(1000)\n    \n    for appointment in appointments:\n        if isinstance(appointment.get('created_at'), str):\n            appointment['created_at'] = datetime.fromisoformat(appointment['created_at'])\n    \n    return appointments\n\n@api_router.get(\"/admin/billing\", response_model=List[Billing])\nasync def get_all_billing(current_user: User = Depends(get_admin_user)):\n    bills = await db.billing.find({}, {\"_id\": 0}).sort(\"created_at\", -1).to_list(1000)\n    \n    for bill in bills:\n        if isinstance(bill.get('created_at'), str):\n            bill['created_at'] = datetime.fromisoformat(bill['created_at'])\n    \n    return bills\n\n@api_router.get(\"/admin/stats\")\nasync def get_admin_stats(current_user: User = Depends(get_admin_user)):\n    total_patients = await db.users.count_documents({\"role\": \"patient\"})\n    total_doctors = await db.doctors.count_documents({})\n    total_appointments = await db.appointments.count_documents({})\n    pending_bills = await db.billing.count_documents({\"payment_status\": \"pending\"})\n    \n    return {\n        \"total_patients\": total_patients,\n        \"total_doctors\": total_doctors,\n        \"total_appointments\": total_appointments,\n        \"pending_bills\": pending_bills\n    }\n\n# ==================== ROOT ROUTE ====================\n\n@api_router.get(\"/\")\nasync def root():\n    return {\"message\": \"Hospital Management System API\"}\n\n# Include the router in the main app\napp.include_router(api_router)\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_credentials=True,\n    allow_origins=os.environ.get('CORS_ORIGINS', '*').split(','),\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@app.on_event(\"shutdown\")\nasync def shutdown_db_client():\n    client.close()\n"}]}, "type": "mcp_tool"}
Observation: Successfully wrote 1 files:
- /app/backend/server.py